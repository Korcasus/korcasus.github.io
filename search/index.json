[{"content":"들어가기에 앞서 안녕하세요.\nSynology DS220+ 구매한 뒤로 Bitwarden, WebDAV, \u0026hellip; 다양한 용도로 사용하고있습니다.\n이전까지는 DuckDNS와 함께 DSM 6.X 사용중이었습니다만, DSM 업데이트 이후로 만들어두었던 자동화 프로세스가 동작하지 않더라구요. 이번 기회에 갖고싶던 Domain을 CloudFlare에서 Domain 구매를 한 뒤, 새롭게 프로세스를 정리하였습니다.\n공식 가이드 대로 진행했던 과정을 순차적으로 정리하려고 합니다.\nDomain 구입과 DDNS 설정에 대한 내용은 기회가 되면 작성하도록 하겠습니다.\n사용한 환경 DSM 7.X Synology DS220+ Domain Provider : CloudFlare Let\u0026rsquo;s Encrypt란? HTTPS를 사용할 때는 CA(인증기관)에서 제공하는 인증서를 사용합니다.\n원하는 도메인으로 인증서를 발급하고자 할때, 업체마다 다른 가격을 지불해야합니다. Let\u0026rsquo;s Encrypt는 비영리 기관으로서 무료로 TLS인증서를 제공합니다.\n장점은 무료로 인증서를 제공받을 수 있지만,\n단점으로는 타업체는 유효기간이 1년인데 비해 짧은 3개월이라는 점입니다.\nacme.sh 는 뭔가요? Let\u0026rsquo;s Encrypt는 ACME 프로토콜을 사용하여 도메인 소유자인지 확인한 뒤에 인증서를 발급합니다. 인증서 발급을 위해서는 ACME 클라이언트 소프트웨어를 선택해야하는데요.\nCertBot 사용을 권장하지만, 상황에 따라 다른 소프트웨어를 선택할 수 있습니다. acme.sh는 bash를 사용해 인증서를 발급해 줄 수 있는 대체 소프트웨어입니다.\n본인의 선호도에 따라 선택할 수 있습니다.\n상세한 내용은 공식문서를 참고해주세요.\nCloudFlare API Token 발급 인증서 발급 절차에 대해 정확하게 알지는 못해도, 파악한 흐름은 아래와 같습니다.\n원하는 Domain의 인증서 발급 요청 (to Let\u0026rsquo;s Encrypt) 해당 Domain의 소유자임을 증명하기 위해 TXT Record값을 응답값으로 받음 CloudFlare API를 사용하여 TXT Record 값을 등록 TXT Record값을 확인한 후, 인증서 발급 위 과정에서 사용되는 CloudFlare API를 사용하기위해 Token 발급을 진행합니다.\nGlobal Key로도 사용가능하지만, 필요이상의 권한을 가지고 있기때문에 진행하진 않습니다.\ntoken을 발급하고자 하는 Domain을 선택하면, 아래의 같은 Home 화면이 나타납니다.\n빨간색 화살표를 클릭합니다.\nAPI Token 생성 버튼을 누르면, 아래의 같은 페이지가 나타나게됩니다.\n우리는 DNS 관련된 수정 권한을 Token을 발행해야하기 때문에, 빨간색 화살표의 버튼을 누릅니다.\n아래의 이미지에서 1번에 권한이 필요한 Domain을 선택합니다.\n그뒤에는 2번을 선택해 바로 생성하도록 합니다.\n정상적으로 진행되었다면, Token값을 확인할 수 있습니다.\n이 값은 더이상 볼 수 없기 때문에 잘 기억해주시기 바랍니다.\nACME 설치 및 인증서 발급 인증서 발급을 진행해줄 Client를 설치하도록 하겠습니다.\n아래의 명령어대로 설치를 진행하도록 합니다.\n계정은 root로 진행합니다.\n1 2 3 4 5 6 7 $ sudo su $ cd ~ $ wget https://github.com/acmesh-official/acme.sh/archive/master.tar.gz $ tar xvf master.tar.gz $ cd acme.sh-master/ $ ./acme.sh --install --nocron --home /usr/local/share/acme.sh --accountemail \u0026#34;email@gmailcom\u0026#34; $ source ~/.profile 이제 인증서 생성을 진행해 볼텐데요.\n아래의 환경 변수들을 만들어 줍니다.\n1 2 3 4 # 발급해둔 API Token export CF_Token=\u0026#34;MY_SECRET_TOKEN_SUCH_SECRET\u0026#34; # CloudFlare Email export CF_Email=\u0026#34;myemail@example.com\u0026#34; 아래의 명령어들을 실행해서 인증서를 생성해보겠습니다.\n1 2 3 4 5 6 $ cd /usr/local/share/acme.sh # 여기에 사용할 Domain을 지정 해줍니다. # Ex) *.my-domain.com $ export CERT_DOMAIN=\u0026#34;your-domain.tld\u0026#34; $ export CERT_DNS=\u0026#34;dns_cf\u0026#34; $ /usr/local/share/acme.sh/acme.sh --issue --home . -d \u0026#34;$CERT_DOMAIN\u0026#34; --dns \u0026#34;$CERT_DNS\u0026#34; 위의 마지막 명렁어를 실행했을때, 에러없이 마무리되었다면 정상적으로 된 것입니다.\n만약 email을 update하라는 문구가 출력된다면 아래처럼 진행해주세요.\n1 $ /usr/local/share/acme.sh//usr/local/share/acme.sh/acme.sh --register-account -m 이메일 --issue --home . -d \u0026#39;*.도메인\u0026#39; --dns \u0026#34;$CERT_DNS\u0026#34; 혹여나 문제가 생긴다면 댓글로 문의주세요.\n기본 인증서 교체 신규로 생성한 인증서를 기본 인증서로 교체해보겠습니다.\n1 2 3 4 5 $ cd /usr/local/share/acme.sh $ export SYNO_Username=\u0026#39;관리자 계정\u0026#39; $ export SYNO_Password=\u0026#39;관리자 비밀번호\u0026#39; $ export SYNO_Certificate=\u0026#34;인증서 설명\u0026#34; $ /usr/local/share/acme.sh/acme.sh --deploy --home . -d \u0026#34;$CERT_DOMAIN\u0026#34; --deploy-hook synology_dsm Success가 출력된다면, 정상적으로 마무리된 것입니다.\n시놀로지 제어판-\u0026gt; 보안 -\u0026gt; 인증서로 들어가서 잘 등록되었는지 확인해봅니다.\n또는 브라우저에서 DSM에 접속한 뒤 새로고침해서 인증서 정보를 확인해주세요.\n만약 OTP를 설정해두셨다면, 위 과정을 진행하면서 SYNO_TOTP_SECRET 값을 설정해주라는 출력과 함께 에러가 발생할 것입니다.\n관리자 계정으로 로그인 할때, OTP 인증을 거치게 설정을 해두었기때문에 당연하다고 볼 수 있습니다. 출력된 메시지대로 값을 지정해주는 것도 방법이겠지만, 중요한 정보이기 때문에 선뜻 작성하기엔 내키지 않습니다. (관리자 뚫리면 어차피 소용없지만, 괜히 그렇더라구요..;;)\n이를 대체할 수 있는 값이 있는데, SYNO_DID 입니다.\nDeviceID값을 의미합니다. 이 값을 얻기위해서는 DSM에 로그인시 Remember this device에 체크한 후, 관리자 계정으로 로그인하면 Cookie로 저장됩니다.\n개발자 모드로 들어가서 이 값을 복사한뒤, 환경변수로 지정해 줍니다.\n위의 설명한 방식은 http 프로토콜을 사용하여 localhost에 인증서 교체 요청을 합니다.\n특별히 문제될건 없지만, 혹~~~~~시나 무조건 https 프로토콜을 사용해야한다!!! 라고 생각하시는 분이 계시다면\n아래의 2개 환경변수를 지정해준뒤, --insecure argument를 추가한뒤 실행해주면 https 프로토콜을 사용하게 됩니다.\n1 2 3 4 # 앞서 지정한 환경변수도 필요로 합니다. $ export SYNO_Scheme=\u0026#34;https\u0026#34; $ export SYNO_Port=\u0026#34;5001\u0026#34; $ /usr/local/share/acme.sh/acme.sh --deploy --insecure --home . -d \u0026#34;$CERT_DOMAIN\u0026#34; --deploy-hook synology_dsm 인증서 갱신 스케줄러 설정 인증서 유효기간이 3개월이기 때문에, 3개월마다 갱신작업을 해주어야합니다.\n하지만 이 작업을 매번 수행하기엔\u0026hellip; 놀랍도록 귀찮습니다.\n만료일에 가까워지면 갱신해야되는 초조함은 덤 입니다.\n이 번거로운 일에서 벗어나기 위해 자동화를 하겠습니다.\n제어한 -\u0026gt; 서비스 -\u0026gt; 작업 스케줄러 -\u0026gt; 생성 -\u0026gt; 예약된 작업 -\u0026gt; 사용자 정의 스크립트를 순서대로 선택합니다.\n이미지로는 아래와 같습니다. 빨간원 숫자 순서대로 진행합니다.\n하나의 팝업창 나타날텐데요.\n이미지처럼 3가지 값을 확인해줍니다.\nDSM6 버전까지는 root로 진행해야 인증서 교체가 가능했는데요.\n7 버전에서 다른계정으로 실행해도 되는지 테스트 해보진 않았습니다.\n다음으로는 언제실행할지 스케줄을 지정할 차례입니다.\n이미지처럼 설정할 경우 매주 토요일 오전 1시에 갱신을 시도하려고 할겁니다.\n선호하는 요일, 시간을 지정해주세요.\n매달 실행할 수 있게 변경 가능하지만, 갱신은 만료 1개월 전부터 가능합니다.\n첫번째이자 마지막 갱신 시도하는 날에 모종의 이유로 실패할 경우, 위에서 진행하셨던걸 다시해주셔야합니다.\n그래서 안전하게 매주 실행하도록 설정했습니다. 다음으로는 실행할 스크립트를 지정하는 단계입니다.\n알림 설정해두신 분이라면, 실행 상세정보를 이메일로 보내기를 체크해주면 좋습니다.\n잘 실행되는걸 메일 오는것으로 확인할 수 있을 테니까요.\n저의경우에는 메일 대신에 텔레그램으로 메시지 오도록 변경했습니다. 이와 관련해서는 따로 포스트 하겠습니다.\n사용자 정의 스크립트는 이미지처럼 인증서를 갱신하는 스크립트를 넣어줍니다.\n간단합니다. 한줄의 커맨드만 입력해주면 됩니다.\n1 /usr/local/share/acme.sh/acme.sh --cron --home /usr/local/share/acme.sh/ 이제 설정 완료하시면 아래의 같은 팝업이 출력됩니다.\n사뿐히 확인버튼 눌러주시면 됩니다.\n알림 외에도 실행한 로그를 확인하고 싶으실수 있는데요.\n아래 이미지처럼 로그 경로를 설정할 수 있습니다. 저의경우에 log 디렉토리로 지정했습니다.\n이와같이 지정했을 경우 스케줄러 로그는 /volume1/log/synoscheduler 경로에 저장됩니다.\n우리가 실행한 작업의 로그는 /volume1/log/synoscheduler/${task_number}/${실행시간} 경로에서 확인하실수 있습니다.\ntask_number는 스케줄러가 몇번째로 만들어졌는지 의미하는 값으로 보입니다.\noutput.log는 실행하며 출력된 결과이고, script.log는 실행한 스크립트를 볼 수 있습니다.\n정리 왜 이렇게 까지 해야되나 궁금해 하실수도 있습니다.\n집에서만 사용하도록 하신경우라면 이 과정 전혀 필요없습니다. 왜냐하면 외부에서 접근이 불가능하니까요.\n하지만 외부에서 접근을 허용하는 경우라면 이야기가 달라집니다.\n설정을 해두신 시점 이후로, 수시로 타국가에서 접근을 시도합니다. 보안 허점을 찾으려고 하는 거죠. http 통신은 보안상 문제가 있기 때문에, 이 상황에서 http를 사용해서 외부에서 접근하면\u0026hellip; 더 이야기 안해도 아실거라 생각합니다.\n이러한 이유로 https를 사용하게된거고, 최소한의 방어수단을 갖춘 셈입니다.\n여튼 여기까지 진행하셨다면, CloudFlare의 Domain에 TLS인증서 기반의 https를 사용할 수 있는 환경을 만드신 겁니다. 진행하느라 고생 많으셨습니다.👏👏\n저도 이번에 새롭게 설정하다보니, 자동 갱신이 잘 되는지는 확인하진 못했습니다.\n2개월 뒤에 내용을 보충 하도록 하겠습니다.\n","date":"2022-11-21T22:23:00+09:00","permalink":"https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/","title":"Automate Synology Let's Encrypt Certificate"},{"content":"Hugo Blog 만들기-2 개요 지난번 글을 통해, Hugo로 Blog를 만들어 보았습니다.\n이번에는 블로그 운영하는데 있어, 필수라고 생각되는 내용들을 적용해보도록 하겠습니다.\nCustom 설정하기 Stack 테마를 Git SubModule로 등록하여 블로그를 만들었습니다.\n사용하는건 좋지만 입맛에 맞게 수정하려면 테마를 변경해 주어야합니다.\n하지만 직접 수정한다면 테마를 업데이트할때마다 충돌이 발생할테고, SubModule로 등록한 의미가 퇴색 됩니다. 이를 방지하기 위한 방법을 설명하겠습니다.\nthemes/hugo-theme-stack/layouts/partials/header.html 파일을 수정해야하는 상황을 가정해보겠습니다. 이 파일을 layouts/partials/header.html로 복사한뒤, 원하는 대로 수정합니다.\nbuild를 할 경우 복사해온 파일을 사용하게 됩니다.\nasset과 static도 동일합니다.\n테마에 사용된 동일한 디자인의 아이콘을 추가할때 위와같은 방법으로 진행할 수 있습니다.\n좀 더 세심히 수정해보고 싶으시다면, 이 글을 참고하시면 큰 도움이 될것 같습니다.\nGoogle 검색 노출 해당 글을 참고하였습니다 구글 검색 결과에 노출되기 위해서는, 구글 검색엔진에 우리 홈페이지도 검색되게해줘~~ 라고 요청을 해야합니다.\n이 작업은 홈페이지 소유자가 Google Search Console 요청할 수 있습니다.\n홈페이지 형태에 따라 소유자임을 증명하는 방법이 달라집니다.\n시작하기를 누르면 아래와 같은 페이지가 나타납니다. URL 접두어에 Github blog 주소를 작성해줍니다. 도메인을 만들어서 운영중이시라면 도메인으로 생성해주세요.\nURL 접두어로 신청했다면, 해당 페이지의 소유자인지 확인해 주어야 합니다. HTML파일을 다운로드하여, static 디렉토리에 추가해줍니다. build하면 자동으로 public 디렉토리에 포함됩니다.\n그리고 public 디렉토리에 sitemap.xml이 존재해야 합니다.\n만약 없다면, build를 한번 해주시면 됩니다.\n\u0026lt;계정\u0026gt;.github.io/sitemap.xml로 접속했을때, 어떤 결과들이 나온다면 정상적으로 된 겁니다.\n검색 노출되기까지는 시간이 좀 걸리니, 느긋하게 기다린뒤 Search Console에서 확인해 봅시다.\nGoogle Analytics 적용 Github 으로 블로그를 운영할 경우, 평균 방문자 수가 얼마인지 간단한 통계조차도 볼 수 없습니다. 이러한 지표는 블로그 운영하는데 있어 재미(?)를 느끼게 하는데 큰 역할을 한다고 생각합니다.\n이런 제약사항을 해결하고, 블로그에 접속하는 사용자들을 분석(?)해보고 싶어 Google Analytics 를 적용해보았습니다.\n해당 글을 참고하였습니다 진행하시기 전에, 광고차단을 해제해두시는것을 추천합니다. (적용되었는지 확인하는데 문제가 생길 수 있습니다.) Google Analytics 신청 상세한 신청 과정을 설명하자니, 이미 진행해버려 동일하게 설명하긴 어려울 것 같습니다.\n개인정보도 포함되어있구요.\n대신 저보다 더 상세히 작성해주신 분들도 많으니, 참고해서 신청해주시면 됩니다.\n애널리틱스 계정, 속성 및 앱 까지 모두 신청하셨다면 사전 준비는 모두 되었다고 생각하시면 됩니다.\n이제는 analytics가 적용된 script와 GA Tracking ID를 확인해 보겠습니다.\n애널리틱스를 적용할 속성 및 앱의 데이터스트림을 생성해 줍니다.\n생성해준 뒤 웹 스트림 세부정보를 들어가면 아래와 같은 이미지를 보실 수 있습니다.\n측정 ID 아래에 적힌 값이 GA Tracking ID를 의미합니다.\nscript는 빨간색 화살표를 클릭해보면 확인할 수 있습니다.\n클릭해보면 아래와 이미지의 섹션에서 확인할 수 있습니다.\n모자이크 한 부분이 analytics를 적용할 수 있는 script입니다.\nScript와 GA Tracking ID 잘 저장해주세요.\nInternal Template을 사용하여 Google Analytics 활성화 Hugo 공식 Guide에서는 config.yaml에 설정만 해준다면, 손쉽게 적용할수 있다고 안내 합니다. 설정 하는방법은 아래와 같습니다.\n1 googleAnalytics: G-MEASUREMENT_ID blog에 배포한 뒤 실시간 접속자 counting이 되는지 확인해 봅니다. 뒤에서 설명하겠지만, 홈 화면에서 실시간 접속자 수를 확인할 수 있습니다. 이 단계에서 잘 적용되었다면, Script 수동 설치는 진행하지 않아도 됩니다.\nScript 수동 설치 신청하며 복사해두었던 script를 layout에 추가하여 적용합니다.\nscript를 복사하며 잘 살펴보셨다면 아시겠지만 head 태그에 추가해야된다고 안내하고 있습니다.\n사용중인 테마의 head 태그 부분을 확인해보겠습니다. (stack 테마를 기준으로 설명합니다.)\n우선 블로그를 구성하는 가장 상위(?)의 html을 확인해보겠습니다. themes/hugo-theme-stack/layouts/_default/baseof.html 입니다.\n현 기준으로는 아래처럼 구성되어있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34; dir=\u0026#34;{{ default `ltr` .Language.LanguageDirection }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{- partial \u0026#34;head/head.html\u0026#34; . -}} {{- block \u0026#34;head\u0026#34; . -}}{{ end }} \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;{{ block `body-class` . }}{{ end }}\u0026#34;\u0026gt; {{- partial \u0026#34;head/colorScheme\u0026#34; . -}} {{/* The container is wider when there\u0026#39;s any activated widget */}} {{- $hasWidget := false -}} {{- range .Site.Params.widgets -}} {{- if gt (len .) 0 -}} {{- $hasWidget = true -}} {{- end -}} {{- end -}} \u0026lt;div class=\u0026#34;container main-container flex on-phone--column {{ if $hasWidget }}extended{{ else }}compact{{ end }}\u0026#34;\u0026gt; {{- block \u0026#34;left-sidebar\u0026#34; . -}} {{ partial \u0026#34;sidebar/left.html\u0026#34; . }} {{- end -}} \u0026lt;main class=\u0026#34;main full-width\u0026#34;\u0026gt; {{- block \u0026#34;main\u0026#34; . }}{{- end }} \u0026lt;/main\u0026gt; {{- block \u0026#34;right-sidebar\u0026#34; . -}}{{ end }} \u0026lt;/div\u0026gt; {{ partial \u0026#34;footer/include.html\u0026#34; . }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; head 태그 안에 추가하기위해 head/head.html를 확인해보겠습니다.\nthemes/hugo-theme-stack/layouts/partials/head/head.html을 보시면 됩니다.\n아래처럼 만들어져 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;meta charset=\u0026#39;utf-8\u0026#39;\u0026gt; \u0026lt;meta name=\u0026#39;viewport\u0026#39; content=\u0026#39;width=device-width, initial-scale=1\u0026#39;\u0026gt; {{- $description := partialCached \u0026#34;data/description\u0026#34; . .RelPermalink -}} \u0026lt;meta name=\u0026#39;description\u0026#39; content=\u0026#39;{{ $description }}\u0026#39;\u0026gt; {{- $title := partialCached \u0026#34;data/title\u0026#34; . .RelPermalink -}} \u0026lt;title\u0026gt;{{ $title }}\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#39;canonical\u0026#39; href=\u0026#39;{{ .Permalink }}\u0026#39;\u0026gt; {{- partial \u0026#34;head/style.html\u0026#34; . -}} {{- partial \u0026#34;head/script.html\u0026#34; . -}} {{- partial \u0026#34;head/opengraph/include.html\u0026#34; . -}} {{- range .AlternativeOutputFormats -}} \u0026lt;link rel=\u0026#34;{{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; href=\u0026#34;{{ .Permalink | safeURL }}\u0026#34;\u0026gt; {{- end -}} {{ with .Site.Params.favicon }} \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;{{ . }}\u0026#34; /\u0026gt; {{ end }} {{- template \u0026#34;_internal/google_analytics.html\u0026#34; . -}} {{- partial \u0026#34;head/custom.html\u0026#34; . -}} script를 추가해야되니까 head/script.html에 추가하면 좋을것으로 보이네요. 실제로 파일을 확인해보겠습니다. 경로는 themes/hugo-theme-stack/layouts/partials/head/head.html 입니다.\n열어보면 아시겠지만, 비어있습니다.\n무슨 내용이 있었다면 custom하며 보완해주어야겠지만, 비어있으므로 걱정할 필요가 없습니다.\nlaygouts/partials/head/script.html을 만들어, 복사해둔 스크립트를 추가해주면 됩니다.\n적용 확인 애널리틱스 홈 화면을 들어갑니다.\n정상 적용되었다면, 지난 30분 동안의 사용자에 counting 됩니다.\n정리 첫번째 글로 Hugo로 Static Site Generate, 테마적용, 댓글 시스템 연동까지 진행해보았고 이번 글을 통해 블로그를 고도화(Custom 방법, 구글 검색노출, 구글 analytics) 해보았습니다.\n다음 글은 애드센스와 github action 적용을 주제로 작성할 예정입니다.\n감사합니다.\n","date":"2022-11-15T20:23:45+09:00","permalink":"https://korcasus.github.io/p/hugo-blog-%EB%A7%8C%EB%93%A4%EA%B8%B0-2/","title":"Hugo Blog 만들기-2"},{"content":"Hugo Blog 만들기-1 Hugo란? Go로 구현된 빠르고 현대적인 Static Site Generator입니다.\nVisitor Request가 발생할때마다 동적으로 페이지를 생성하는 시스템과는 다르게, Content를 만들거나 업데이트할때 Build가 됩니다. 사전에 Build된 Page를 보여주기 때문에, viewer에게 최적의 경험을 제공해줄 수 있습니다. Hosting에도 제약이 없으며, CDN에도 문제없이 동작합니다.\nHugo는 Database가 필요없고 Ruby, Python or PHP와 같은 Expensive Runtime에 Dependency가 없습니다.\n특징을 정리해보면 아래와 같습니다.\nBuild가 극단적으로 빠르다. (페이지마다 1ms 이하) cross platform 지원 liveReload지원 강력한 테마 어디서든 Hosting할 수 있다. … 상세한 내용은 Hugo 문서를 참고해주세요.\nHugo 설치 Mac을 주력으로 사용하기 때문에, Mac 기준으로 설명하겠습니다.\n타 운영체제를 사용한다면, Reference를 참고해서 설치를 진행해주세요.\nPrerequisites Git Hugo module Git submodule … GoLang ≥ 1.18 Go를 사용하며, Git을 통해 Submodule을 관리하기때문에 위의 2개를 사전에 설치해주어야합니다.\n1 2 3 4 5 6 # Hombrew Package manager 사용 $ brew install hugo # 정상적으로 설치되었는지 확인 $ hugo version hugo v0.104.3+extended darwin/arm64 BuildDate=unknown Apple Silicon을 사용중이라면, 위처럼 darwin/arm64로 나타나는지 확인해줍니다.\nGithub repository 2개 생성 User Github Page로 사용할 Repository와 Markdown을 기록할 Repository를 구분하기 위한 용도로 나누어 사용하기 위해서 입니다.\n1개의 Repository로 통합해도 되지만, 작성해둔 content를 쉽게 copy해갈 수 있으므로 사전에 방지하기 위해 구분하여 사용하려 합니다.\n저의 경우에는 아래의 2개의 respository를 생성했습니다.\ntechnical-blog .github.io (ex. korcasus.github.io) Hugo로 프로젝트 만들기 Hugo를 사용해서 default project를 만들어줍니다.\n생성되는 프로젝트는 아래처럼 구성됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 $ hugo new site technical-blog $ tree . ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 자세하게 알아보고 사용하고 싶다면 Reference를 한번 읽어보는걸 권장합니다.\n블로그에 이쁜 옷을 입혀줄 차례입니다.\n본인이 직접 테마를 만들것이 아니라면, 공개된 테마를 사용하는게 좋습니다.\n다양한 테마가 존재하므로, 문서에서 찾아보고 본인에 맞는 테마를 사용하도록 합니다.\n저의 경우에는 Stack이 가장 이쁘고, 문서화가 잘 되어있다고 생각했습니다.\n그래서 Stack을 기준으로 블로그 구현한 것을 설명하겠습니다.\n1 2 3 4 5 $ cd technical-blog # 다른 테마의 경우 # git submodule add https://github.com/${테마Repository}.git themes/${테마이름} $ git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 위에처럼 Submodule로 추가해둔다면, 추후 테마 업데이트 하기가 쉬워집니다.\nHugo에 Module이라는 것도 있는데, 이 방법으로도 대체 가능합니다. 관심있다면 적용해보는것도 좋아보입니다.\n테마가 정상적으로 설치되었다면, 테마의 설정파일을 사용하기 위해 기본 config file을 복사해와야 합니다.\n${project}/themes/hugo-theme-stack/exampleSite/config.yaml 파일을 복사해 ${project}/config.yaml 에 옮겨줍니다.\nGithub Page로 사용하기위해서는 config.yaml의 일부를 변경해주어야 합니다.\n아래의 예시에 주석에 해당되는 부분을 변경해주도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Github page로 사용할 URL로 변경해주어야합니다. baseurl: https://korcasus.github.io/ languageCode: en-us theme: hugo-theme-stack paginate: 5 title: Read Write languages: en: languageName: English title: Read Write weight: 1 disqusShortname: hugo-theme-stack ... 추가한 테마가 정상적으로 동작하는지 project 디렉토리에서 build 및 서버 실행을 해보도록 하겠습니다.\n이미 어느정도 blog를 만든뒤에 작성하는거라, 완전 아래와 동일하게 나오진 않지만 비슷하게 출력되었던 것으로 기억합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ hugo server -D Start building sites … hugo v0.104.3+extended darwin/arm64 BuildDate=unknown | EN -------------------+----- Pages | 41 Paginator pages | 2 Non-page files | 4 Static files | 0 Processed images | 18 Aliases | 18 Sitemaps | 1 Cleaned | 0 Built in 1494 ms Watching for changes in /Users/user/Workspace/technical-blog/{archetypes,assets,content,data,layouts,static,themes} Watching for config changes in /Users/user/Workspace/technical-blog/config.yaml, /Users/user/Workspace/technical-blog/themes/hugo-theme-stack/config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop Build된 결과를 보기 위해 http://localhost:1313 으로 접속했을때 페이지가 보인다면, 여기까지는 잘 진행되었다고 판단하시면 됩니다.\nGit Repo 연결 및 ShellScipt 작성 Hugo로 만들어진 Project를 개인(Privarte) Repository에 등록하고, Hugo로 Build된 결과를 Github Page로 연동하는 작업입니다.\n그 뒤로는 배포에 사용하기 위한 ShellScript에 대해 설명하겠습니다.\n아래의 명령어들을 실행하면, 처음에 만들어둔 2개 Repository에 용도에 맞게 사용하게 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 # 현재 위치 확인 $ pwd /Users/user/Workspaces/blog # blog -\u0026gt; blog 레포지토리 연결 # git remote add origin http://github.com/\u0026lt;username\u0026gt;/technical-blog.git $ git remote add origin http://github.com/korcasus/technical-blog.git # blog/public -\u0026gt; \u0026lt;username\u0026gt;.github.io 연결 # git submodule add -b master http://github.com/\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git public $ git submodule add -b master http://github.com/korcasus/korcasus.github.io.git public 발행할 Contents를 작성을 완료한 후, Hugo로 Build해주는 과정이 필요로 합니다.\nBuild된 결과물은 public 디렉토리에 생성됩니다. 이를 Github Page에 반영해주는 과정이 필요로 합니다.\n매번 따로 수행하기보다는 배포 스크립트로 만들어 실행하는것이 운영하기 쉽습니다.\n저의 경우에는 아래의 스크립트를 통해, 배포를 합니다. (Reference)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. # hugo -t \u0026lt;여러분의 테마\u0026gt; hugo -t hugo-tranquilpeak-theme # Go To Public folder, sub module commit cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. # blog 저장소 Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin master 1 2 3 4 5 # deploy.sh 실행 파일 권한 부여 $ chmod 777 deploy.sh # 배포 실행 $ ./deploy.sh Post 작성 발행할 글을 작성할때 아래처럼 명령어를 입력하면 Hugo에서 Markdown을 생성해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 $ cd $project # hugo new ${content내 directory}/${사용할 파일명}.md $ hugo new post/hugo-blog-2/index.md Content \u0026#34;/Users/user/Workspace/technical-blog/content/post/hugo-blog-2/index.md\u0026#34; created $ cat content/post/hugo-blog-2/index.md --- title: \u0026#34;Hugo Blog 2\u0026#34; date: 2022-11-14T23:58:09+09:00 draft: true --- 주의해야할 점이 2가지 있습니다.\ncontent directory내에 생성된다는 점입니다. 확장자를 md로 해야합니다. 첫번째는 생성되는 경로를 정확히 파악하기 위해 주의해주는 것이 좋습니다.\n두번째는 확장자를 md로 하지않을 경우, 명령어로 post생성할때 에러가 발생합니다.\nHugo에서 archetypes 디렉토리를 포함하고있는데, default.md 파일이 존재합니다.\n명령어를 통해 확장자 md파일을 만들때, 기본값으로 사용됩니다.\n하지만 여기에 포함되지않은 확장자 파일을 만들경우, 기본값으로 사용할 파일이 존재하지않으므로 에러가 발생합니다. default.md 파일을 확인해보면 아래와 같습니다.\n1 2 3 4 5 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- Utterences(Github 댓글 위젯) 연동 Stack 테마에서는 아래와 같은 댓글 시스템들을 지원합니다. (참고)\nCactus Cusdis Disqus DisqusJS Giscus Gitalk Remark42 Twikoo utterances Vssue Waline 이 중에 OpenSource이고, github과 연동하여 쉽게 사용가능한 Utterences를 사용합니다.\n사용하기 위해서는 별도의 Repository가 추가로 필요합니다. 여기서 사용한 Repo이름은 blog-comments 입니다.\n첨부한 GIF대로 진행하시면 됩니다. 잊지말고 utterances app연동 진행해주세요!\nBlog Post와 Issue Mapping 방식을 다르게 하고싶다면, 선호하시는 것으로 선택하시면 됩니다. 만들어진 Script를 테마에 적용해보도록 하겠습니다.\nblog/themes/${테마}/layouts/partials/comments/provider 경로에 사용하고자 하는 댓글 시스템에 직접 수정방법도 있습니다.\n하지만 이는 추후 테마 업데이트 하는데 문제가 발생할 수 있으므로 제외합니다.\n테마에서 제공하는 config.yaml를 수정해서 댓글 시스템에 적용해보겠습니다.\n프로젝트 루트 디렉토리에 복사해둔 config.yaml을 사용합니다. 아래처럼 comments를 사용할건지, 사용할 provider를 지정해줄 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 params: comments: enabled: true provider: disqus disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: issueTerm: pathname label: 추출한 Script를 적용하면 아래처럼 됩니다.\n만약 Issue Mapping을 설명한 방법과 다르게 하셨다면 blog/themes/${테마}/layouts/partials/comments/provider/utterances.html 를 확인해서 Script에 맞게끔 값을 입력해주세요.\n1 2 3 4 5 6 7 params: comments: enabled: true provider: utterances utterances: repo: Korcasus/blog-comments issueTerm: title 정상적으로 만들어졌다면 게시글 하단에 아래와 같이 추가되어있는것을 보실 수 있습니다.\n댓글이 잘 작성되는지 확인해보겠습니다.\n로그인후 테스트 댓글을 작성해보았습니다.\n작성된 댓글이 Github Issue로 잘 등록되었습니다.\n정리 여기까지 Hugo로 Static Site Generate, 테마적용, 댓글 시스템 연동까지 진행해보았습니다.\n다음에는 만든 블로그를 고도화(Custom 방법, 구글 검색노출, 구글 analytics) 해보겠습니다.\n감사합니다.\n","date":"2022-11-14T23:11:35+09:00","permalink":"https://korcasus.github.io/p/hugo-blog-%EB%A7%8C%EB%93%A4%EA%B8%B0-1/","title":"Hugo Blog 만들기-1"}]