<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Synology on Read Write</title>
        <link>https://korcasus.github.io/categories/synology/</link>
        <description>Recent content in Synology on Read Write</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sat, 26 Aug 2023 22:30:49 +0900</lastBuildDate><atom:link href="https://korcasus.github.io/categories/synology/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Use Docker in Jenkins Docker</title>
        <link>https://korcasus.github.io/p/use-docker-in-jenkins-docker/</link>
        <pubDate>Sat, 26 Aug 2023 22:30:49 +0900</pubDate>
        
        <guid>https://korcasus.github.io/p/use-docker-in-jenkins-docker/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Synology에서 여러 응용 프로그램을 설치해서 사용하기 위해서 Docker를 애용합니다.&lt;br&gt;
Docker로 Jenkins 를 사용중인데, Jenkins에서도 Docker를 사용해야하는 상황이 생겨 진행하게 되었습니다.&lt;br&gt;
Synology가 아닌 다른 Machine에서도 비슷하게 진행되지만, 이번 설명은 Synology를 기준으로 설명하겠습니다.&lt;/p&gt;
&lt;p&gt;설명한 방법은 Host의 docker sock을 공유하는 방법입니다.&lt;/p&gt;
&lt;h2 id=&#34;prerequisite&#34;&gt;Prerequisite&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Jenkins Container Using Official Image&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;progress&#34;&gt;Progress&lt;/h2&gt;
&lt;p&gt;생각보다 어렵지 않습니다. 차근차근히 진행하면 쉽습니다.&lt;br&gt;
DSM 7.2로 업데이트한 후에 진행한 작업이라, 캡처한 이미지가 차이가 있을 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;1-docker-sock-공유&#34;&gt;1. Docker sock 공유&lt;/h3&gt;
&lt;p&gt;Synology에 설치해준 Docker sock과 container에서 사용할 Docker sock을 binding 하는 작업을 해야합니다. &lt;br&gt;
아래의 명령어대로 설정해 주면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -p &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;webPort&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:8080 -p &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;agentPort&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:50000 -d -v /var/run/docker.sock:/var/run/docker.sock -v &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;hostJenkinsDir&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:/var/jenkins_home jenkins/jenkins:lts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 예시로 들면 아래와 같습니다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -p 8080:8080 -p 50000:50000 -d -v /var/run/docker.sock:/var/run/docker.sock -v /docker/jenkins/home:/var/jenkins_home jenkins/jenkins:lts
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;하지만 Synology에서는 &lt;code&gt;/&lt;/code&gt; directory 설정할 수 없기떄문에, SSH로 접속해서 설정해주어야합니다.&lt;br&gt;
SSH로 접속해서 Docker command를 사용할 준비를 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://korcasus.github.io/p/use-docker-in-jenkins-docker/update_command_in_host.jpg&#34;
	width=&#34;1868&#34;
	height=&#34;860&#34;
	srcset=&#34;https://korcasus.github.io/p/use-docker-in-jenkins-docker/update_command_in_host_hucdd27cc99166e43e175b379001281f77_320576_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/use-docker-in-jenkins-docker/update_command_in_host_hucdd27cc99166e43e175b379001281f77_320576_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;update_command_in_host&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;217&#34;
		data-flex-basis=&#34;521px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;저의 경우에는 위의 이미지처럼 container의 volume을 update할 수 있는 설정이 있습니다.&lt;br&gt;
그래서 아래의 명령어를 사용해서 volume binding 하였습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker container update -v /var/run/docker.sock:/var/run/docker.sock -v /docker/jenkins/home:/var/jenkins_home &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;containerId&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이렇게 변경한 volume binding은 synology web ui상에서는 보이지 않기 때문에, 명령어를 통해 잘 변경되었는지 확인해야합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker container inspect &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;containerId&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          ...,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;s2&#34;&gt;&amp;#34;Mounts&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;bind&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Source&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;/volume1/docker/jenkins/home&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Destination&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/jenkins_home&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Mode&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;rw&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;RW&amp;#34;&lt;/span&gt;: true,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Propagation&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;rprivate&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;bind&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Source&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/run/docker.sock&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Destination&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/run/docker.sock&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Mode&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;rw&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;RW&amp;#34;&lt;/span&gt;: true,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;Propagation&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;rprivate&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위처럼 &lt;code&gt;docker.sock&lt;/code&gt;이 추가되었다면, 정상적으로 된 것입니다.&lt;br&gt;
혹시 docker container update 명령어를 통해 volume binding을 할 수 없다면, 새로 container를 만드는것이 편하겠습니다.&lt;br&gt;
직접 하진않았지만 아래의 명령어처럼 입력하면 되지않을까 싶습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --restart &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;policy&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; --name &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;jenkins&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; -p &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;webPort&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:8080 -p &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;agentPort&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:50000 -d -v /var/run/docker.sock:/var/run/docker.sock -v &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;hostJenkinsDir&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:/var/jenkins_home jenkins/jenkins:lts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 예시로 들면 아래와 같습니다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --restart always --name jenkins -p 8080:8080 -p 50000:50000 -d -v /var/run/docker.sock:/var/run/docker.sock -v /docker/jenkins/home:/var/jenkins_home jenkins/jenkins:lts
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;항상 재시작 하는 옵션을 &lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/run/#restart-policies---restart&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식문서&lt;/a&gt;를 참고하였습니다.&lt;br&gt;
본인의 필요에 따라 설정해주세요.&lt;/p&gt;
&lt;h3 id=&#34;2-jenkins에-docker-설치&#34;&gt;2. Jenkins에 Docker 설치&lt;/h3&gt;
&lt;p&gt;Dockerfile을 새로 만들어, Docker를 설치하는 스크립트를 입력해주는 방법도 있습니다.
하지만 새로 이미지를 만들고 관리하는건 번거롭기도하고, volume binding을 해서 데이터가 유지되는 상황이니 설치 스크립트를 저장해두는게 좋다고 생각이 들었습니다.&lt;br&gt;
(Jenkins를 업그레이드하거나 Container가 삭제된다면, 설치스크립트를 새로 실행해주긴 해야하지만요.)&lt;/p&gt;
&lt;p&gt;아래의 내용의 스크립트를 host의 &lt;code&gt;/docker/jenkins/home/install_jenkins.sh&lt;/code&gt;로 만들어 주었습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;curl https://get.docker.com/ &amp;gt; dockerinstall &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; chmod &lt;span class=&#34;m&#34;&gt;777&lt;/span&gt; dockerinstall &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./dockerinstall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chmod &lt;span class=&#34;m&#34;&gt;666&lt;/span&gt; /var/run/docker.sock
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;설치하는데 조금 시간이 걸리긴합니다. 기다리면, 설치가 완료된것을 보실 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;3-동작-확인&#34;&gt;3. 동작 확인&lt;/h3&gt;
&lt;p&gt;Jenkins Container와 Web UI에서 Docker command가 잘 되는지 확인해보겠습니다. &lt;br&gt;
우선은 Container에서 확인해보겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -it &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;containerId&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; /bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 예시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -it f0f5398c9a62 /bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker container ls --all
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위의 명령어들을 실행하면 Container에 접속하였고, 시놀로지에서 구동중인 Container 리스트를 확인할 수 있게됩니다. &lt;br&gt;
구동중인 Container가 없을 수는 없지만, 에러는 발생해서는 안됩니다.&lt;/p&gt;
&lt;p&gt;위에까지만 확인해도 문제는 없을텐데, 저는 혹시나 싶어 더 확인해보았습니다.&lt;br&gt;
아래처럼 Jenkins pipeline으로 실행해보았습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pipeline &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    agent any
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    stages &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        stage&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Run Container&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            steps &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                script &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    // Docker 컨테이너 실행
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    docker.image&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;hello-world:latest&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.run&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://korcasus.github.io/p/use-docker-in-jenkins-docker/console_job.jpg&#34;
	width=&#34;1406&#34;
	height=&#34;1494&#34;
	srcset=&#34;https://korcasus.github.io/p/use-docker-in-jenkins-docker/console_job_hud49da568400d9062178718c4e59fe2d3_194182_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/use-docker-in-jenkins-docker/console_job_hud49da568400d9062178718c4e59fe2d3_194182_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;console_job&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;94&#34;
		data-flex-basis=&#34;225px&#34;
	
&gt;
위의 결과까지 나오면, jenkins에서도 docker를 마음껏 사용하실 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Docker로 구동한 Jenkins에서 Docker를 실행할 수 있도록 해보았습니다. &lt;br&gt;
Container로 만들어진 Jenkins에서 Host의 Docker에 접근할 수 있게 만든다는게, 편리하긴 하지만 보안상으로는 좋지않아 보입니다.   &lt;br&gt;
사용하신다면 Container와 Host의 보안을 좀 더 신경 써서 사용해주시면, 안전할 것 같습니다.&lt;/p&gt;
&lt;p&gt;다른 분들에게 도움이 되면 좋겠네요. 감사합니다.&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://faun.pub/how-to-install-docker-in-jenkins-container-4c49ba40b373&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://faun.pub/how-to-install-docker-in-jenkins-container-4c49ba40b373&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jenkinsci/docker/blob/master/README.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jenkinsci/docker/blob/master/README.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Upgrade Vaultwarden 1.29.1</title>
        <link>https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/</link>
        <pubDate>Mon, 14 Aug 2023 23:09:01 +0900</pubDate>
        
        <guid>https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/</guid>
        <description>&lt;h2 id=&#34;before-to-start&#34;&gt;Before to start&lt;/h2&gt;
&lt;p&gt;맥을 사용하시는분이라면 Keychain에 익숙하실겁니다. 비밀번호를 저장하고 관리해주는 어플리케이션이죠.&lt;br&gt;
요즘에는 크롬이나 엣지 브라우저에서도 제공하고있습니다.&lt;br&gt;
저는 웹 뿐만이 아니라, 맥에서도 편하게 사용할수 있는것을 원했기 때문에 다른 툴을 사용하고있습니다.&lt;br&gt;
더 자세히 이야기하면 길어지기 때문에, 짧게 이야기하면 Valutwarden이라는 Bitwarden의 Compact버전을 synology에 설치해서 사용하고있습니다.&lt;/p&gt;
&lt;p&gt;이번에 Valutwarden이 1.29.0 버전으로 업그레이드 되면서 실시간 동기화가 가능해졌다는 소식에 업그레이드를 결심하였습니다.&lt;/p&gt;
&lt;h2 id=&#34;objective&#34;&gt;Objective&lt;/h2&gt;
&lt;p&gt;Valutwarden을 1.29.1로 업그레이드하면서, 필요한 설정(ex. 실시간 동기화)들을 추가한다.&lt;/p&gt;
&lt;h2 id=&#34;upgrade&#34;&gt;Upgrade&lt;/h2&gt;
&lt;h3 id=&#34;upgrade-guide-찾기&#34;&gt;Upgrade Guide 찾기&lt;/h3&gt;
&lt;p&gt;업그레이드 하기전까지 사용하던 docker image를 latest를 사용했기 때문에, 몇버전을 사용하고 있었는지는 모르겠습니다. &lt;br&gt;
하지만 최신버전이 1.29.x버전이기 때문에 minor 버전만 신경써주면 될것으로 생각했습니다.&lt;/p&gt;
&lt;p&gt;공식 Github에 들어가보면 &lt;a class=&#34;link&#34; href=&#34;https://github.com/dani-garcia/vaultwarden/wiki/Updating-the-vaultwarden-image&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Updating valutwarden image&lt;/a&gt; Wiki가 존재합니다.
살펴보니 컨테이너 환경에서 업그레이드를 하는 방법만 설명하였고, 버전이 바뀌면서 변경해야하는 설정에 대해서는 언급이 없습니다.&lt;br&gt;
저의 경우에는 이럴때 &lt;a class=&#34;link&#34; href=&#34;https://github.com/dani-garcia/vaultwarden/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Release Note&lt;/a&gt;를 살펴봅니다. 정석은 모든 변경사항을 읽어야하지만, 선 업그레이드 후 변경하기로 마음먹었습니다 😇&lt;/p&gt;
&lt;p&gt;그래도 업그레이드 하는게 1.29.x이니 1.29.0으로 올라오면서 큰 변경이 어떤건지 보았습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- WebSocket notifications now work via the default HTTP port. No need for `WEBSOCKET_ENABLED` and a separate port anymore.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- The proxy examples still need to be updated for this. Support for the old websockets port 3012 will remain for the time being.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- Mobile Client push notification support, see #3304 thanks @GeekCornerGH!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- Web-Vault updated to v2023.5.0 (v2023.5.1 does not add any improvements for us)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- The latest Bitwarden Directory Connector can be used now (v2022.11.0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- Storing passkeys is supported, though the clients are not yet released. So, it might be we need to make some changes once they are released.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- See: #3593, thanks @GeekCornerGH!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;저한테는 3가지가 눈에 들어왔습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WebSocket notifications now work via the default HTTP port. No need for &lt;code&gt;WEBSOCKET_ENABLED&lt;/code&gt; and a separate port anymore.&lt;/li&gt;
&lt;li&gt;Mobile Client push notification support, see #3304 thanks @GeekCornerGH!&lt;/li&gt;
&lt;li&gt;Storing passkeys is supported, though the clients are not yet released. So, it might be we need to make some changes once they are released.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;1번&lt;/code&gt;의 경우에는 폰에서 사용중인 앱에서 변경사항이 발생시, valutwarden 서버에 반영하기 위해서 필수로 설정해야하는 기능입니다. (아니면 서버와 휴대폰앱이 별도의 데이터를 가지게 됩니다.) &lt;br&gt;
이것 때문에 2개의 포트를 열어두고 사용하는게 필요했었는데, 이번 업데이트로 1개로 통합되었다고 하네요.&lt;br&gt;
공유기에 개방해둔 포트를 줄일수 있을뿐더러, 신경써야되는 환경변수가 하나 줄었습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2번&lt;/code&gt;의 경우에는 실시간 동기화입니다. 이거는 나중에 자세히 보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3번&lt;/code&gt;은 Passkey에 관한 내용입니다. 애플과 구글에서 지원하기 시작한 보안 방법중 하나인데, 고도화된 보안환경을 제공한다고 합니다. &lt;br&gt;
저도 자세히 살펴보진 않아서,&amp;hellip; 설명은 넘어가겠습니다.&lt;br&gt;
보안에 신경은 항상 써야하기때문에, 지원가능해지면 사용해보고싶네요.&lt;/p&gt;
&lt;h3 id=&#34;추가할-configuration-보기&#34;&gt;추가할 Configuration 보기&lt;/h3&gt;
&lt;p&gt;비밀번호 관리 프로그램을 개인 서버에 올려서 사용한다는건, 책임도 본인이 진다는 뜻입니다.&lt;br&gt;
따라서 해킹당하지않도록 문제의 소지가 될수 있는 기능은 닫아두는게 좋습니다. (기본은 닫혀있을겁니다.) &lt;br&gt;
그래서 사용하지 않을 기능과 사용할 기능들을 살펴보기 위해서 문서를 읽어보기 시작했습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dani-garcia/vaultwarden/wiki/Configuration-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Github wiki&lt;/a&gt;를 읽어보면 자세하게 나와있습니다. &lt;br&gt;
config.json보다는 환경변수를 사용하는 방법을 권고하네요.&lt;/p&gt;
&lt;p&gt;리스트는 아래와 같습니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/config.jpg&#34;
	width=&#34;578&#34;
	height=&#34;1122&#34;
	srcset=&#34;https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/config_hucdd27cc99166e43e175b379001281f77_147088_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/config_hucdd27cc99166e43e175b379001281f77_147088_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;config&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;51&#34;
		data-flex-basis=&#34;123px&#34;
	
&gt;&lt;br&gt;
여러 관심가는 설정들이 많지만, 저는 2,3,4번 항목이 눈에 들어왔고 반영하기로 하였습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2번항목은 추가 사용자 가입금지&lt;/li&gt;
&lt;li&gt;3번항목은 초대를 통한 사용자 가입금지&lt;/li&gt;
&lt;li&gt;4번항목은 admin계정 운영
&lt;ul&gt;
&lt;li&gt;admin을 별도로 관리하고싶지않았기에, 기본값이 admin계정 비활성화인지 살펴봤습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위에 나열한 내용들을 반영하기 위해서 아래와 같이 설정 해주었습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SIGNUPS_ALLOWED : false
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INVITATIONS_ALLOWED : false
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;그러고보니 실시간 동기화도 설정이 필요하네요.&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/dani-garcia/vaultwarden/wiki/Enabling-Mobile-Client-push-notification&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;7번 항목&lt;/a&gt;에 등록되어있습니다.&lt;br&gt;
문서를 살펴보면 아시겠지만, 3개 환경변수 설정을 요구합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- PUSH_ENABLED=true
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- PUSH_INSTALLATION_ID=
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- PUSH_INSTALLATION_KEY=
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;ID와 KEY는 &lt;a class=&#34;link&#34; href=&#34;https://bitwarden.com/host/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bitwarden 홈페이지&lt;/a&gt;에서 발급받으라고 합니다.&lt;br&gt;
Self Hosting은 지원하지 않는건가? 싶었는데, 다행히 지원하네요.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/auto-sync-request.jpg&#34;
	width=&#34;1870&#34;
	height=&#34;1154&#34;
	srcset=&#34;https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/auto-sync-request_hucdd27cc99166e43e175b379001281f77_211109_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/auto-sync-request_hucdd27cc99166e43e175b379001281f77_211109_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;auto-sync-request&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;388px&#34;
	
&gt;&lt;br&gt;
Self Hosting에서 이용중인 이메일과 Data Region을 설정해줍니다.&lt;br&gt;
Data Region은 뭔가싶겠지만, Wiki에 US로 두고 쓰라고 적혀있네요. Europe은 안될수도있다고&amp;hellip;
그리고 업그레이드 직후에 App에서 실시간 동기화가 안될경우 재설치하라고 가이드하고있습니다.&lt;br&gt;
업그레이드 완료한 후에, 한번 실시간 동기화 해보시는걸 추천합니다. (저는 직후에 바로해봤는데 잘되더라구요)&lt;/p&gt;
&lt;h3 id=&#34;upgrade-하기&#34;&gt;Upgrade 하기&lt;/h3&gt;
&lt;p&gt;본인 Synology에 Valutwarden을 설치하신 분이라면, 업그레이드 하는 과정은 다 아실거라 판단해서 과정은 생략했습니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/container.jpg&#34;
	width=&#34;2342&#34;
	height=&#34;1242&#34;
	srcset=&#34;https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/container_hud49da568400d9062178718c4e59fe2d3_197488_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/upgrade-vaultwarden-1.29.1/container_hud49da568400d9062178718c4e59fe2d3_197488_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;container info&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;188&#34;
		data-flex-basis=&#34;452px&#34;
	
&gt;&lt;br&gt;
업그레이드 완료한 컨테이너 설정값인데, 이전과 큰 차이는 없습니다.&lt;/p&gt;
&lt;p&gt;완료후, docker container log확인과 valutwarden web에 접속해보았습니다.&lt;br&gt;
log에는 서버를 실행하는데 문제없었고, web에 접속해보니 에러페이지 뜨지않고 기존 데이터도 잘 있습니다.&lt;br&gt;
실시간 동기화도 테스트해보았는데, 조금 이상하더라구요.
Web에서 변경한 내용은 App에서 별도의 액션 없이 잘 반영되었는데, App에서 변경한 내용은 Web에서 새롭게 로딩해주어야 했습니다. &lt;br&gt;
(새로고침했다가 다시 비밀번호 입력했습니다 -ㅅ-)&lt;br&gt;
큰 이슈까진 아니기 때문에, 업그레이드 잘 되었다고 판단하였습니다.&lt;/p&gt;
&lt;h2 id=&#34;후기&#34;&gt;후기&lt;/h2&gt;
&lt;p&gt;Valutwarden은 Bitwarden의 Compact를 추구하는 만큼 꼭 필요한 기능들만 가지고 있습니다.
이런 이유때문에 업그레이드 하더라도 많이 변경하지않아도 되는것이 좋게 느껴졌습니다.&lt;/p&gt;
&lt;p&gt;별도로 운영되기 때문에 업그레이드를 하는데 개인의 노력이 필요할겁니다. 후원을 받긴하지만 오픈소스 환경에서 자발적으로 해주시는 분들에게 감사할 따름이네요.&lt;br&gt;
저도 언젠가 필요한 기능을 추가하기 위해 Contribute하는 순간이 오겠죠?? 곧 올거라 믿습니다.&lt;/p&gt;
&lt;p&gt;감사합니다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Automate Synology Let&#39;s Encrypt Certificate</title>
        <link>https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/</link>
        <pubDate>Mon, 21 Nov 2022 22:23:00 +0900</pubDate>
        
        <guid>https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/</guid>
        <description>&lt;h2 id=&#34;들어가기에-앞서&#34;&gt;들어가기에 앞서&lt;/h2&gt;
&lt;p&gt;안녕하세요.&lt;br&gt;
Synology DS220+ 구매한 뒤로 Bitwarden, WebDAV, &amp;hellip; 다양한 용도로 사용하고있습니다.&lt;br&gt;
이전까지는 DuckDNS와 함께 DSM 6.X 사용중이었습니다만, DSM 업데이트 이후로 만들어두었던 자동화 프로세스가 동작하지 않더라구요. &lt;br&gt;
이번 기회에 갖고싶던 Domain을 CloudFlare에서 Domain 구매를 한 뒤, 새롭게 프로세스를 정리하였습니다.&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/acmesh-official/acme.sh/wiki/Synology-NAS-Guide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식 가이드&lt;/a&gt; 대로 진행했던 과정을 순차적으로 정리하려고 합니다.&lt;/p&gt;
&lt;p&gt;Domain 구입과 DDNS 설정에 대한 내용은 기회가 되면 작성하도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;사용한-환경&#34;&gt;사용한 환경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DSM 7.X&lt;/li&gt;
&lt;li&gt;Synology DS220+&lt;/li&gt;
&lt;li&gt;Domain Provider : CloudFlare&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lets-encrypt란&#34;&gt;Let&amp;rsquo;s Encrypt란?&lt;/h3&gt;
&lt;p&gt;HTTPS를 사용할 때는 CA(인증기관)에서 제공하는 인증서를 사용합니다.&lt;br&gt;
원하는 도메인으로 인증서를 발급하고자 할때, 업체마다 다른 가격을 지불해야합니다.   &lt;br&gt;
Let&amp;rsquo;s Encrypt는 비영리 기관으로서 무료로 TLS인증서를 제공합니다.&lt;/p&gt;
&lt;p&gt;장점은 무료로 인증서를 제공받을 수 있지만,&lt;br&gt;
단점으로는 타업체는 유효기간이 1년인데 비해 짧은 3개월이라는 점입니다.&lt;/p&gt;
&lt;h3 id=&#34;acmesh-는-뭔가요&#34;&gt;acme.sh 는 뭔가요?&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s Encrypt는 ACME 프로토콜을 사용하여 도메인 소유자인지 확인한 뒤에 인증서를 발급합니다.   &lt;br&gt;
인증서 발급을 위해서는 ACME 클라이언트 소프트웨어를 선택해야하는데요.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CertBot&lt;/code&gt; 사용을 권장하지만, 상황에 따라 다른 소프트웨어를 선택할 수 있습니다. &lt;br&gt;
&lt;code&gt;acme.sh&lt;/code&gt;는 bash를 사용해 인증서를 발급해 줄 수 있는 대체 소프트웨어입니다.&lt;br&gt;
본인의 선호도에 따라 선택할 수 있습니다.&lt;br&gt;
상세한 내용은 &lt;a class=&#34;link&#34; href=&#34;https://letsencrypt.org/ko/docs/client-options/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식문서&lt;/a&gt;를 참고해주세요.&lt;/p&gt;
&lt;h2 id=&#34;cloudflare-api-token-발급&#34;&gt;CloudFlare API Token 발급&lt;/h2&gt;
&lt;p&gt;인증서 발급 절차에 대해 정확하게 알지는 못해도, 파악한 흐름은 아래와 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;원하는 Domain의 인증서 발급 요청 (to Let&amp;rsquo;s Encrypt)&lt;/li&gt;
&lt;li&gt;해당 Domain의 소유자임을 증명하기 위해 TXT Record값을 응답값으로 받음&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://api.cloudflare.com/#dns-records-for-a-zone-create-dns-record&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CloudFlare API&lt;/a&gt;를 사용하여 TXT Record 값을 등록&lt;/li&gt;
&lt;li&gt;TXT Record값을 확인한 후, 인증서 발급&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 과정에서 사용되는 CloudFlare API를 사용하기위해 Token 발급을 진행합니다.&lt;br&gt;
Global Key로도 사용가능하지만, 필요이상의 권한을 가지고 있기때문에 진행하진 않습니다.&lt;/p&gt;
&lt;p&gt;token을 발급하고자 하는 Domain을 선택하면, 아래의 같은 Home 화면이 나타납니다.&lt;br&gt;
빨간색 화살표를 클릭합니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/cloudflare_home.jpg&#34;
	width=&#34;2696&#34;
	height=&#34;2966&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/cloudflare_home_hud49da568400d9062178718c4e59fe2d3_651351_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/cloudflare_home_hud49da568400d9062178718c4e59fe2d3_651351_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cloudflare_home&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;90&#34;
		data-flex-basis=&#34;218px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;API Token 생성 버튼을 누르면, 아래의 같은 페이지가 나타나게됩니다.&lt;br&gt;
우리는 DNS 관련된 수정 권한을 Token을 발행해야하기 때문에, 빨간색 화살표의 버튼을 누릅니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/choose_template.jpg&#34;
	width=&#34;1406&#34;
	height=&#34;1748&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/choose_template_hud49da568400d9062178718c4e59fe2d3_271736_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/choose_template_hud49da568400d9062178718c4e59fe2d3_271736_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;choose_template&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;80&#34;
		data-flex-basis=&#34;193px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;아래의 이미지에서 1번에 권한이 필요한 Domain을 선택합니다.&lt;br&gt;
그뒤에는 2번을 선택해 바로 생성하도록 합니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/api_token_create.jpg&#34;
	width=&#34;1708&#34;
	height=&#34;1892&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/api_token_create_hud49da568400d9062178718c4e59fe2d3_233114_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/api_token_create_hud49da568400d9062178718c4e59fe2d3_233114_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;api_token_create&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;90&#34;
		data-flex-basis=&#34;216px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;정상적으로 진행되었다면, Token값을 확인할 수 있습니다.&lt;br&gt;
이 값은 더이상 볼 수 없기 때문에 잘 기억해주시기 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;acme-설치-및-인증서-발급&#34;&gt;ACME 설치 및 인증서 발급&lt;/h2&gt;
&lt;p&gt;인증서 발급을 진행해줄 Client를 설치하도록 하겠습니다.&lt;br&gt;
아래의 명령어대로 설치를 진행하도록 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;계정은 root로 진행합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo su
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ wget https://github.com/acmesh-official/acme.sh/archive/master.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ tar xvf master.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; acme.sh-master/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ./acme.sh --install --nocron --home /usr/local/share/acme.sh --accountemail &lt;span class=&#34;s2&#34;&gt;&amp;#34;email@gmailcom&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; ~/.profile
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이제 인증서 생성을 진행해 볼텐데요.&lt;br&gt;
아래의 환경 변수들을 만들어 줍니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 발급해둔 API Token&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CF_Token&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;MY_SECRET_TOKEN_SUCH_SECRET&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# CloudFlare Email&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CF_Email&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;myemail@example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;아래의 명령어들을 실행해서 인증서를 생성해보겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /usr/local/share/acme.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 여기에 사용할 Domain을 지정 해줍니다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Ex) *.my-domain.com&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CERT_DOMAIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;your-domain.tld&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CERT_DNS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;dns_cf&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ /usr/local/share/acme.sh/acme.sh --issue --home . -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$CERT_DOMAIN&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; --dns &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$CERT_DNS&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위의 마지막 명렁어를 실행했을때, 에러없이 마무리되었다면 정상적으로 된 것입니다.&lt;br&gt;
만약 email을 update하라는 문구가 출력된다면 아래처럼 진행해주세요.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ /usr/local/share/acme.sh//usr/local/share/acme.sh/acme.sh --register-account -m 이메일 --issue --home . -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;*.도메인&amp;#39;&lt;/span&gt; --dns &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$CERT_DNS&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;혹여나 문제가 생긴다면 댓글로 문의주세요.&lt;/p&gt;
&lt;h2 id=&#34;기본-인증서-교체&#34;&gt;기본 인증서 교체&lt;/h2&gt;
&lt;p&gt;신규로 생성한 인증서를 기본 인증서로 교체해보겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /usr/local/share/acme.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SYNO_Username&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;관리자 계정&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SYNO_Password&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;관리자 비밀번호&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SYNO_Certificate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;인증서 설명&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ /usr/local/share/acme.sh/acme.sh --deploy --home . -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$CERT_DOMAIN&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; --deploy-hook synology_dsm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/certificate_success.jpg&#34;
	width=&#34;2048&#34;
	height=&#34;1774&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/certificate_success_hud49da568400d9062178718c4e59fe2d3_402785_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/certificate_success_hud49da568400d9062178718c4e59fe2d3_402785_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;certificate_success&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;115&#34;
		data-flex-basis=&#34;277px&#34;
	
&gt;
Success가 출력된다면, 정상적으로 마무리된 것입니다.&lt;br&gt;
&lt;code&gt;시놀로지 제어판-&amp;gt; 보안 -&amp;gt; 인증서&lt;/code&gt;로 들어가서 잘 등록되었는지 확인해봅니다.&lt;br&gt;
또는 브라우저에서 DSM에 접속한 뒤 새로고침해서 인증서 정보를 확인해주세요.&lt;/p&gt;
&lt;p&gt;만약 OTP를 설정해두셨다면, 위 과정을 진행하면서 &lt;code&gt;SYNO_TOTP_SECRET&lt;/code&gt; 값을 설정해주라는 출력과 함께 에러가 발생할 것입니다.&lt;br&gt;
관리자 계정으로 로그인 할때, OTP 인증을 거치게 설정을 해두었기때문에 당연하다고 볼 수 있습니다.
출력된 메시지대로 값을 지정해주는 것도 방법이겠지만, 중요한 정보이기 때문에 선뜻 작성하기엔 내키지 않습니다. (관리자 뚫리면 어차피 소용없지만, 괜히 그렇더라구요..;;)&lt;br&gt;
이를 대체할 수 있는 값이 있는데, &lt;code&gt;SYNO_DID&lt;/code&gt; 입니다.&lt;/p&gt;
&lt;p&gt;DeviceID값을 의미합니다. 이 값을 얻기위해서는 DSM에 로그인시 &lt;code&gt;Remember this device&lt;/code&gt;에 체크한 후, 관리자 계정으로 로그인하면 Cookie로 저장됩니다.&lt;br&gt;
개발자 모드로 들어가서 이 값을 복사한뒤, 환경변수로 지정해 줍니다.&lt;/p&gt;
&lt;p&gt;위의 설명한 방식은 http 프로토콜을 사용하여 localhost에 인증서 교체 요청을 합니다.&lt;br&gt;
특별히 문제될건 없지만, 혹~~~~~시나 무조건 https 프로토콜을 사용해야한다!!! 라고 생각하시는 분이 계시다면&lt;br&gt;
아래의 2개 환경변수를 지정해준뒤, &lt;code&gt;--insecure&lt;/code&gt; argument를 추가한뒤 실행해주면 https 프로토콜을 사용하게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 앞서 지정한 환경변수도 필요로 합니다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SYNO_Scheme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;https&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SYNO_Port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;5001&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ /usr/local/share/acme.sh/acme.sh --deploy --insecure --home . -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$CERT_DOMAIN&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; --deploy-hook synology_dsm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;인증서-갱신-스케줄러-설정&#34;&gt;인증서 갱신 스케줄러 설정&lt;/h2&gt;
&lt;p&gt;인증서 유효기간이 3개월이기 때문에, 3개월마다 갱신작업을 해주어야합니다.&lt;br&gt;
하지만 이 작업을 매번 수행하기엔&amp;hellip; 놀랍도록 귀찮습니다.&lt;br&gt;
만료일에 가까워지면 갱신해야되는 초조함은 덤 입니다.&lt;br&gt;
이 번거로운 일에서 벗어나기 위해 자동화를 하겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;제어한 -&amp;gt; 서비스 -&amp;gt; 작업 스케줄러 -&amp;gt; 생성 -&amp;gt; 예약된 작업 -&amp;gt; 사용자 정의 스크립트&lt;/code&gt;를 순서대로 선택합니다.&lt;br&gt;
이미지로는 아래와 같습니다. 빨간원 숫자 순서대로 진행합니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_scheduler.jpg&#34;
	width=&#34;1962&#34;
	height=&#34;1310&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_scheduler_hud49da568400d9062178718c4e59fe2d3_179432_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_scheduler_hud49da568400d9062178718c4e59fe2d3_179432_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;create_scheduler&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;359px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;하나의 팝업창 나타날텐데요.&lt;br&gt;
이미지처럼 3가지 값을 확인해줍니다.&lt;br&gt;
DSM6 버전까지는 &lt;code&gt;root&lt;/code&gt;로 진행해야 인증서 교체가 가능했는데요.&lt;br&gt;
7 버전에서 다른계정으로 실행해도 되는지 테스트 해보진 않았습니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_1.jpg&#34;
	width=&#34;932&#34;
	height=&#34;510&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_1_hud49da568400d9062178718c4e59fe2d3_53297_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_1_hud49da568400d9062178718c4e59fe2d3_53297_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;create_1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;182&#34;
		data-flex-basis=&#34;438px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;다음으로는 언제실행할지 스케줄을 지정할 차례입니다.&lt;br&gt;
이미지처럼 설정할 경우 매주 토요일 오전 1시에 갱신을 시도하려고 할겁니다.&lt;br&gt;
선호하는 요일, 시간을 지정해주세요.&lt;/p&gt;
&lt;p&gt;매달 실행할 수 있게 변경 가능하지만, 갱신은 만료 1개월 전부터 가능합니다.&lt;br&gt;
첫번째이자 마지막 갱신 시도하는 날에 모종의 이유로 실패할 경우, 위에서 진행하셨던걸 다시해주셔야합니다.&lt;br&gt;
그래서 안전하게 매주 실행하도록 설정했습니다.
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_2.jpg&#34;
	width=&#34;874&#34;
	height=&#34;904&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_2_hucdd27cc99166e43e175b379001281f77_65336_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_2_hucdd27cc99166e43e175b379001281f77_65336_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;create_2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;96&#34;
		data-flex-basis=&#34;232px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;다음으로는 실행할 스크립트를 지정하는 단계입니다.&lt;br&gt;
알림 설정해두신 분이라면, &lt;code&gt;실행 상세정보를 이메일로 보내기&lt;/code&gt;를 체크해주면 좋습니다.&lt;br&gt;
잘 실행되는걸 메일 오는것으로 확인할 수 있을 테니까요.&lt;br&gt;
저의경우에는 메일 대신에 텔레그램으로 메시지 오도록 변경했습니다. 이와 관련해서는 따로 포스트 하겠습니다.&lt;br&gt;
사용자 정의 스크립트는 이미지처럼 인증서를 갱신하는 스크립트를 넣어줍니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_3.jpg&#34;
	width=&#34;884&#34;
	height=&#34;732&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_3_hucdd27cc99166e43e175b379001281f77_72087_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_3_hucdd27cc99166e43e175b379001281f77_72087_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;create_3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;120&#34;
		data-flex-basis=&#34;289px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;간단합니다. 한줄의 커맨드만 입력해주면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/usr/local/share/acme.sh/acme.sh --cron --home /usr/local/share/acme.sh/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이제 설정 완료하시면 아래의 같은 팝업이 출력됩니다.&lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_warn.jpg&#34;
	width=&#34;1264&#34;
	height=&#34;386&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_warn_hucdd27cc99166e43e175b379001281f77_60486_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/create_warn_hucdd27cc99166e43e175b379001281f77_60486_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;create_warn&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;327&#34;
		data-flex-basis=&#34;785px&#34;
	
&gt;
사뿐히 확인버튼 눌러주시면 됩니다.&lt;/p&gt;
&lt;p&gt;알림 외에도 실행한 로그를 확인하고 싶으실수 있는데요.&lt;br&gt;
아래 이미지처럼 로그 경로를 설정할 수 있습니다. &lt;br&gt;
&lt;img src=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/scheduler_log.jpg&#34;
	width=&#34;1166&#34;
	height=&#34;636&#34;
	srcset=&#34;https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/scheduler_log_hud49da568400d9062178718c4e59fe2d3_73433_480x0_resize_q75_box.jpg 480w, https://korcasus.github.io/p/automate-synology-lets-encrypt-certificate/scheduler_log_hud49da568400d9062178718c4e59fe2d3_73433_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;scheduler_log&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;440px&#34;
	
&gt;
저의경우에 &lt;code&gt;log&lt;/code&gt; 디렉토리로 지정했습니다.&lt;br&gt;
이와같이 지정했을 경우 스케줄러 로그는 &lt;code&gt;/volume1/log/synoscheduler&lt;/code&gt; 경로에 저장됩니다.&lt;br&gt;
우리가 실행한 작업의 로그는 &lt;code&gt;/volume1/log/synoscheduler/${task_number}/${실행시간}&lt;/code&gt; 경로에서 확인하실수 있습니다.&lt;br&gt;
&lt;code&gt;task_number&lt;/code&gt;는 스케줄러가 몇번째로 만들어졌는지 의미하는 값으로 보입니다.&lt;br&gt;
&lt;code&gt;output.log&lt;/code&gt;는 실행하며 출력된 결과이고, &lt;code&gt;script.log&lt;/code&gt;는 실행한 스크립트를 볼 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;정리&#34;&gt;정리&lt;/h2&gt;
&lt;p&gt;왜 이렇게 까지 해야되나 궁금해 하실수도 있습니다.&lt;br&gt;
집에서만 사용하도록 하신경우라면 이 과정 전혀 필요없습니다. 왜냐하면 외부에서 접근이 불가능하니까요.&lt;/p&gt;
&lt;p&gt;하지만 외부에서 접근을 허용하는 경우라면 이야기가 달라집니다.&lt;br&gt;
설정을 해두신 시점 이후로, 수시로 타국가에서 접근을 시도합니다. 보안 허점을 찾으려고 하는 거죠.
http 통신은 보안상 문제가 있기 때문에, 이 상황에서 http를 사용해서 외부에서 접근하면&amp;hellip; 더 이야기 안해도 아실거라 생각합니다.&lt;br&gt;
이러한 이유로 https를 사용하게된거고, 최소한의 방어수단을 갖춘 셈입니다.&lt;/p&gt;
&lt;p&gt;여튼 여기까지 진행하셨다면, CloudFlare의 Domain에 TLS인증서 기반의 https를 사용할 수 있는 환경을 만드신 겁니다. &lt;br&gt;
진행하느라 고생 많으셨습니다.👏👏&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;저도 이번에 새롭게 설정하다보니, 자동 갱신이 잘 되는지는 확인하진 못했습니다.&lt;br&gt;
2개월 뒤에 내용을 보충 하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
